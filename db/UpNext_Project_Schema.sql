--------------------------------------------------------------------------------
-- UpNext Task Management System - Oracle 19c Schema
-- Run as schema owner (e.g., user UPNEXT).
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (A) TABLES
--------------------------------------------------------------------------------

-- USERS: Authentication + global role (ADMIN / MANAGER / MEMBER)
CREATE TABLE USERS (
  USER_ID           NUMBER(10)        PRIMARY KEY,
  USERNAME          VARCHAR2(50)      NOT NULL UNIQUE,
  EMAIL             VARCHAR2(120)     NOT NULL UNIQUE,
  PASSWORD_HASH     VARCHAR2(255)     NOT NULL,
  GLOBAL_ROLE       VARCHAR2(20)      NOT NULL
                     CHECK (GLOBAL_ROLE IN ('ADMIN','MANAGER','MEMBER')),
  STATUS            VARCHAR2(20)      DEFAULT 'ACTIVE'
                     CHECK (STATUS IN ('ACTIVE','SUSPENDED')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_AT        TIMESTAMP
);

-- PROJECTS
CREATE TABLE PROJECTS (
  PROJECT_ID        NUMBER(10)        PRIMARY KEY,
  NAME              VARCHAR2(120)     NOT NULL,
  DESCRIPTION       CLOB,
  OWNER_ID          NUMBER(10)        NOT NULL,
  START_DATE        DATE,
  END_DATE          DATE,
  STATUS            VARCHAR2(20)      DEFAULT 'PLANNING'
                     CHECK (STATUS IN ('PLANNING','ACTIVE','ON_HOLD','COMPLETED','CANCELLED')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_AT        TIMESTAMP,
  CONSTRAINT FK_PROJECTS_OWNER
    FOREIGN KEY (OWNER_ID) REFERENCES USERS(USER_ID)
);

-- PROJECT_MEMBERS (per-project role)
CREATE TABLE PROJECT_MEMBERS (
  PROJECT_MEMBER_ID NUMBER(10)        PRIMARY KEY,
  PROJECT_ID        NUMBER(10)        NOT NULL,
  USER_ID           NUMBER(10)        NOT NULL,
  PROJECT_ROLE      VARCHAR2(20)      NOT NULL
                     CHECK (PROJECT_ROLE IN ('OWNER','MANAGER','MEMBER','VIEWER')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_AT        TIMESTAMP,
  CONSTRAINT UQ_PROJECT_MEM UNIQUE (PROJECT_ID, USER_ID),
  CONSTRAINT FK_PM_PROJECT FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID) ON DELETE CASCADE,
  CONSTRAINT FK_PM_USER    FOREIGN KEY (USER_ID)    REFERENCES USERS(USER_ID)    ON DELETE CASCADE
);

-- TASKS (hierarchical via PARENT_TASK_ID)
CREATE TABLE TASKS (
  TASK_ID           NUMBER(10)        PRIMARY KEY,
  PROJECT_ID        NUMBER(10)        NOT NULL,
  PARENT_TASK_ID    NUMBER(10),  -- NULL for top-level tasks
  TITLE             VARCHAR2(200)     NOT NULL,
  DESCRIPTION       CLOB,
  ASSIGNEE_ID       NUMBER(10),       -- nullable
  STATUS            VARCHAR2(20)      DEFAULT 'TODO'
                     CHECK (STATUS IN ('TODO','IN_PROGRESS','BLOCKED','ON_HOLD','DONE','CANCELLED')),
  PRIORITY          VARCHAR2(10)      DEFAULT 'MEDIUM'
                     CHECK (PRIORITY IN ('LOW','MEDIUM','HIGH','CRITICAL')),
  START_DATE        DATE,
  DUE_DATE          DATE,
  PROGRESS_PCT      NUMBER(5,2)       DEFAULT 0
                     CHECK (PROGRESS_PCT BETWEEN 0 AND 100),
  ESTIMATED_HOURS   NUMBER(7,2),
  ACTUAL_HOURS      NUMBER(7,2),
  IS_BLOCKED        CHAR(1)           DEFAULT 'N'
                     CHECK (IS_BLOCKED IN ('Y','N')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_AT        TIMESTAMP,
  CONSTRAINT FK_TASKS_PROJECT FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID) ON DELETE CASCADE,
  CONSTRAINT FK_TASKS_PARENT  FOREIGN KEY (PARENT_TASK_ID) REFERENCES TASKS(TASK_ID) ON DELETE CASCADE,
  CONSTRAINT FK_TASKS_ASSIGNEE FOREIGN KEY (ASSIGNEE_ID) REFERENCES USERS(USER_ID),
  CONSTRAINT CHK_TASK_DATES CHECK (DUE_DATE IS NULL OR START_DATE IS NULL OR DUE_DATE >= START_DATE)
);

-- TASK_DEPENDENCIES (many-to-many: predecessor blocks successor)
CREATE TABLE TASK_DEPENDENCIES (
  DEP_ID             NUMBER(10) PRIMARY KEY,
  PREDECESSOR_TASK_ID NUMBER(10) NOT NULL,
  SUCCESSOR_TASK_ID   NUMBER(10) NOT NULL,
  CREATED_AT          TIMESTAMP   DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT UQ_TASK_DEP UNIQUE (PREDECESSOR_TASK_ID, SUCCESSOR_TASK_ID),
  CONSTRAINT CHK_NO_SELF_DEP CHECK (PREDECESSOR_TASK_ID <> SUCCESSOR_TASK_ID),
  CONSTRAINT FK_DEP_PRED FOREIGN KEY (PREDECESSOR_TASK_ID) REFERENCES TASKS(TASK_ID) ON DELETE CASCADE,
  CONSTRAINT FK_DEP_SUCC FOREIGN KEY (SUCCESSOR_TASK_ID)   REFERENCES TASKS(TASK_ID) ON DELETE CASCADE
);

-- COMMENTS (optional but useful)
CREATE TABLE COMMENTS (
  COMMENT_ID        NUMBER(10)        PRIMARY KEY,
  TASK_ID           NUMBER(10)        NOT NULL,
  USER_ID           NUMBER(10)        NOT NULL,
  CONTENT           CLOB              NOT NULL,
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT FK_COM_TASK FOREIGN KEY (TASK_ID) REFERENCES TASKS(TASK_ID) ON DELETE CASCADE,
  CONSTRAINT FK_COM_USER FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID) ON DELETE CASCADE
);

-- ATTACHMENTS (optional)
CREATE TABLE ATTACHMENTS (
  ATTACHMENT_ID     NUMBER(10)        PRIMARY KEY,
  TASK_ID           NUMBER(10)        NOT NULL,
  FILE_NAME         VARCHAR2(255)     NOT NULL,
  FILE_PATH         VARCHAR2(1024)    NOT NULL,
  UPLOADED_BY       NUMBER(10)        NOT NULL,
  UPLOADED_AT       TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT FK_ATT_TASK FOREIGN KEY (TASK_ID)     REFERENCES TASKS(TASK_ID) ON DELETE CASCADE,
  CONSTRAINT FK_ATT_USER FOREIGN KEY (UPLOADED_BY) REFERENCES USERS(USER_ID)
);

-- ACTIVITY_LOGS (captures DML on key tables)
CREATE TABLE ACTIVITY_LOGS (
  LOG_ID            NUMBER(12)        PRIMARY KEY,
  OCCURRED_AT       TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  ENTITY_TYPE       VARCHAR2(30)      NOT NULL,   -- 'PROJECT','TASK','PROJECT_MEMBER','TASK_DEPENDENCY', etc.
  ENTITY_ID         NUMBER(12)        NOT NULL,
  ACTION            VARCHAR2(10)      NOT NULL
                     CHECK (ACTION IN ('INSERT','UPDATE','DELETE')),
  PERFORMED_BY      VARCHAR2(128),                  -- set via DBMS_SESSION.SET_IDENTIFIER from app
  PROJECT_ID        NUMBER(10),
  TASK_ID           NUMBER(10),
  DETAILS           CLOB,                           -- JSON-like text
  CONSTRAINT FK_LOG_PROJ FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID),
  CONSTRAINT FK_LOG_TASK FOREIGN KEY (TASK_ID)     REFERENCES TASKS(TASK_ID)
);

-- NOTIFICATIONS (overdue/alerts; UI can poll this)
CREATE TABLE NOTIFICATIONS (
  NOTIF_ID          NUMBER(12)        PRIMARY KEY,
  USER_ID           NUMBER(10)        NOT NULL,
  TASK_ID           NUMBER(10),
  MESSAGE           VARCHAR2(4000)    NOT NULL,
  IS_READ           CHAR(1)           DEFAULT 'N' CHECK (IS_READ IN ('Y','N')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT FK_NOTIF_USER FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID),
  CONSTRAINT FK_NOTIF_TASK FOREIGN KEY (TASK_ID) REFERENCES TASKS(TASK_ID) ON DELETE CASCADE
);

--------------------------------------------------------------------------------
-- (B) INDEXES
--------------------------------------------------------------------------------
CREATE INDEX IX_PROJECTS_OWNER      ON PROJECTS(OWNER_ID);
CREATE INDEX IX_PM_PROJECT          ON PROJECT_MEMBERS(PROJECT_ID);
CREATE INDEX IX_PM_USER             ON PROJECT_MEMBERS(USER_ID);

CREATE INDEX IX_TASKS_PROJECT       ON TASKS(PROJECT_ID);
CREATE INDEX IX_TASKS_PARENT        ON TASKS(PARENT_TASK_ID);
CREATE INDEX IX_TASKS_ASSIGNEE      ON TASKS(ASSIGNEE_ID);
CREATE INDEX IX_TASKS_STATUS        ON TASKS(STATUS);
CREATE INDEX IX_TASKS_DUE_DATE      ON TASKS(DUE_DATE);

CREATE INDEX IX_DEP_PRED            ON TASK_DEPENDENCIES(PREDECESSOR_TASK_ID);
CREATE INDEX IX_DEP_SUCC            ON TASK_DEPENDENCIES(SUCCESSOR_TASK_ID);

CREATE INDEX IX_LOGS_ENTITY         ON ACTIVITY_LOGS(ENTITY_TYPE, ENTITY_ID);
CREATE INDEX IX_LOGS_PROJECT        ON ACTIVITY_LOGS(PROJECT_ID);
CREATE INDEX IX_LOGS_TASK           ON ACTIVITY_LOGS(TASK_ID);

CREATE INDEX IX_NOTIF_USER          ON NOTIFICATIONS(USER_ID);
CREATE INDEX IX_NOTIF_TASK          ON NOTIFICATIONS(TASK_ID);

--------------------------------------------------------------------------------
-- (C) SEQUENCES
--------------------------------------------------------------------------------
CREATE SEQUENCE USERS_SEQ              START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE PROJECTS_SEQ           START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE PROJECT_MEMBERS_SEQ    START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE TASKS_SEQ              START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE TASK_DEP_SEQ           START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE COMMENTS_SEQ           START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE ATTACHMENTS_SEQ        START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE ACTIVITY_LOGS_SEQ      START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE NOTIFICATIONS_SEQ      START WITH 1 INCREMENT BY 1 NOCACHE;

--------------------------------------------------------------------------------
-- (D) ID / TIMESTAMP TRIGGERS
--------------------------------------------------------------------------------
-- USERS
CREATE OR REPLACE TRIGGER TRG_USERS_BI
BEFORE INSERT ON USERS
FOR EACH ROW
BEGIN
  IF :NEW.USER_ID IS NULL THEN
    SELECT USERS_SEQ.NEXTVAL INTO :NEW.USER_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TRG_USERS_BU
BEFORE UPDATE ON USERS
FOR EACH ROW
BEGIN
  :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/

-- PROJECTS
CREATE OR REPLACE TRIGGER TRG_PROJECTS_BI
BEFORE INSERT ON PROJECTS
FOR EACH ROW
BEGIN
  IF :NEW.PROJECT_ID IS NULL THEN
    SELECT PROJECTS_SEQ.NEXTVAL INTO :NEW.PROJECT_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TRG_PROJECTS_BU
BEFORE UPDATE ON PROJECTS
FOR EACH ROW
BEGIN
  :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/

-- PROJECT_MEMBERS
CREATE OR REPLACE TRIGGER TRG_PM_BI
BEFORE INSERT ON PROJECT_MEMBERS
FOR EACH ROW
BEGIN
  IF :NEW.PROJECT_MEMBER_ID IS NULL THEN
    SELECT PROJECT_MEMBERS_SEQ.NEXTVAL INTO :NEW.PROJECT_MEMBER_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TRG_PM_BU
BEFORE UPDATE ON PROJECT_MEMBERS
FOR EACH ROW
BEGIN
  :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/

-- TASKS
CREATE OR REPLACE TRIGGER TRG_TASKS_BI
BEFORE INSERT ON TASKS
FOR EACH ROW
BEGIN
  IF :NEW.TASK_ID IS NULL THEN
    SELECT TASKS_SEQ.NEXTVAL INTO :NEW.TASK_ID FROM DUAL;
  END IF;
  :NEW.PROGRESS_PCT := NVL(:NEW.PROGRESS_PCT, 0);
  :NEW.IS_BLOCKED   := NVL(:NEW.IS_BLOCKED, 'N');
  :NEW.CREATED_AT   := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TRG_TASKS_BU
BEFORE UPDATE ON TASKS
FOR EACH ROW
BEGIN
  :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/

-- TASK_DEPENDENCIES
CREATE OR REPLACE TRIGGER TRG_DEP_BI
BEFORE INSERT ON TASK_DEPENDENCIES
FOR EACH ROW
BEGIN
  IF :NEW.DEP_ID IS NULL THEN
    SELECT TASK_DEP_SEQ.NEXTVAL INTO :NEW.DEP_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/

-- COMMENTS
CREATE OR REPLACE TRIGGER TRG_COMMENTS_BI
BEFORE INSERT ON COMMENTS
FOR EACH ROW
BEGIN
  IF :NEW.COMMENT_ID IS NULL THEN
    SELECT COMMENTS_SEQ.NEXTVAL INTO :NEW.COMMENT_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/

-- ATTACHMENTS
CREATE OR REPLACE TRIGGER TRG_ATTACHMENTS_BI
BEFORE INSERT ON ATTACHMENTS
FOR EACH ROW
BEGIN
  IF :NEW.ATTACHMENT_ID IS NULL THEN
    SELECT ATTACHMENTS_SEQ.NEXTVAL INTO :NEW.ATTACHMENT_ID FROM DUAL;
  END IF;
  :NEW.UPLOADED_AT := NVL(:NEW.UPLOADED_AT, SYSTIMESTAMP);
END;
/

-- ACTIVITY_LOGS
CREATE OR REPLACE TRIGGER TRG_LOGS_BI
BEFORE INSERT ON ACTIVITY_LOGS
FOR EACH ROW
BEGIN
  IF :NEW.LOG_ID IS NULL THEN
    SELECT ACTIVITY_LOGS_SEQ.NEXTVAL INTO :NEW.LOG_ID FROM DUAL;
  END IF;
  :NEW.OCCURRED_AT := NVL(:NEW.OCCURRED_AT, SYSTIMESTAMP);
END;
/

-- NOTIFICATIONS
CREATE OR REPLACE TRIGGER TRG_NOTIF_BI
BEFORE INSERT ON NOTIFICATIONS
FOR EACH ROW
BEGIN
  IF :NEW.NOTIF_ID IS NULL THEN
    SELECT NOTIFICATIONS_SEQ.NEXTVAL INTO :NEW.NOTIF_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/

--------------------------------------------------------------------------------
-- (E) BUSINESS RULE TRIGGERS
--------------------------------------------------------------------------------

-- 1) Dependency enforcement: cannot move to IN_PROGRESS or DONE if any predecessor not DONE
CREATE OR REPLACE TRIGGER TRG_TASKS_CHECK_DEPS
BEFORE UPDATE OF STATUS ON TASKS
FOR EACH ROW
DECLARE
  V_UNFINISHED NUMBER;
BEGIN
  IF :NEW.STATUS IN ('IN_PROGRESS','DONE') THEN
    SELECT COUNT(*)
      INTO V_UNFINISHED
      FROM TASK_DEPENDENCIES D
      JOIN TASKS P ON P.TASK_ID = D.PREDECESSOR_TASK_ID
     WHERE D.SUCCESSOR_TASK_ID = :NEW.TASK_ID
       AND P.STATUS <> 'DONE';
    IF V_UNFINISHED > 0 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Task has unfinished dependencies and cannot be '||:NEW.STATUS);
    END IF;
  END IF;
END;
/
-- (Optional) prevent setting PROGRESS_PCT to 100 unless status DONE
CREATE OR REPLACE TRIGGER TRG_TASKS_PROGRESS_GUARD
BEFORE UPDATE OF PROGRESS_PCT ON TASKS
FOR EACH ROW
BEGIN
  IF :NEW.PROGRESS_PCT = 100 AND :NEW.STATUS <> 'DONE' THEN
    :NEW.STATUS := 'IN_PROGRESS';
  END IF;
END;
/

-- 2) Maintain IS_BLOCKED on successors whenever dependencies change
CREATE OR REPLACE TRIGGER TRG_DEP_RECALC_BLOCK
AFTER INSERT OR UPDATE OR DELETE ON TASK_DEPENDENCIES
FOR EACH ROW
BEGIN
  -- Recalc for the new/updated successor
  IF INSERTING OR UPDATING THEN
    UPDATE TASKS S
       SET IS_BLOCKED = CASE
                          WHEN EXISTS (
                            SELECT 1 FROM TASK_DEPENDENCIES D
                            JOIN TASKS P ON P.TASK_ID = D.PREDECESSOR_TASK_ID
                           WHERE D.SUCCESSOR_TASK_ID = :NEW.SUCCESSOR_TASK_ID
                             AND P.STATUS <> 'DONE'
                          ) THEN 'Y' ELSE 'N'
                        END
     WHERE S.TASK_ID = :NEW.SUCCESSOR_TASK_ID;
  END IF;

  -- Recalc for the old successor on delete/update
  IF DELETING OR UPDATING THEN
    UPDATE TASKS S
       SET IS_BLOCKED = CASE
                          WHEN EXISTS (
                            SELECT 1 FROM TASK_DEPENDENCIES D
                            JOIN TASKS P ON P.TASK_ID = D.PREDECESSOR_TASK_ID
                           WHERE D.SUCCESSOR_TASK_ID = :OLD.SUCCESSOR_TASK_ID
                             AND P.STATUS <> 'DONE'
                          ) THEN 'Y' ELSE 'N'
                        END
     WHERE S.TASK_ID = :OLD.SUCCESSOR_TASK_ID;
  END IF;
END;
/

-- Also recalc blocked flag when a predecessor status changes
CREATE OR REPLACE TRIGGER TRG_TASKS_STATUS_RECALC_BLOCK
AFTER UPDATE OF STATUS ON TASKS
FOR EACH ROW
BEGIN
  UPDATE TASKS S
     SET IS_BLOCKED = CASE
                        WHEN EXISTS (
                          SELECT 1 FROM TASK_DEPENDENCIES D
                          JOIN TASKS P ON P.TASK_ID = D.PREDECESSOR_TASK_ID
                         WHERE D.SUCCESSOR_TASK_ID = S.TASK_ID
                           AND P.STATUS <> 'DONE'
                        ) THEN 'Y' ELSE 'N'
                      END
   WHERE S.TASK_ID IN (
         SELECT D.SUCCESSOR_TASK_ID
           FROM TASK_DEPENDENCIES D
          WHERE D.PREDECESSOR_TASK_ID = :NEW.TASK_ID
   );
END;
/

-- 3) Roll-up parent progress/status from children (compound trigger)
CREATE OR REPLACE TRIGGER TRG_TASKS_ROLLUP
FOR INSERT OR UPDATE OF STATUS, PROGRESS_PCT, PARENT_TASK_ID OR DELETE ON TASKS
COMPOUND TRIGGER
  TYPE T_IDS IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  G_PARENTS T_IDS;
  G_COUNT   PLS_INTEGER := 0;

  PROCEDURE COLLECT_PARENT(P_ID NUMBER) IS
  BEGIN
    IF P_ID IS NOT NULL THEN
      G_COUNT := G_COUNT + 1;
      G_PARENTS(G_COUNT) := P_ID;
    END IF;
  END;

  AFTER EACH ROW IS
  BEGIN
    IF INSERTING THEN
      COLLECT_PARENT(:NEW.PARENT_TASK_ID);
    ELSIF UPDATING THEN
      IF NVL(:NEW.PARENT_TASK_ID,-1) <> NVL(:OLD.PARENT_TASK_ID,-1) THEN
        COLLECT_PARENT(:OLD.PARENT_TASK_ID);
        COLLECT_PARENT(:NEW.PARENT_TASK_ID);
      ELSE
        COLLECT_PARENT(:NEW.PARENT_TASK_ID);
      END IF;
    ELSIF DELETING THEN
      COLLECT_PARENT(:OLD.PARENT_TASK_ID);
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
    -- Deduplicate parent list by updating via subquery
    FOR I IN 1..G_COUNT LOOP
      MERGE INTO TASKS P
      USING (
        SELECT C.PARENT_TASK_ID AS PID,
               COUNT(*) AS TOTAL_CNT,
               SUM(CASE WHEN C.STATUS = 'DONE' THEN 1 ELSE 0 END) AS DONE_CNT,
               ROUND(AVG(C.PROGRESS_PCT),2) AS AVG_PROGRESS
          FROM TASKS C
         WHERE C.PARENT_TASK_ID = G_PARENTS(I)
         GROUP BY C.PARENT_TASK_ID
      ) S
      ON (P.TASK_ID = S.PID)
      WHEN MATCHED THEN
        UPDATE SET
          P.PROGRESS_PCT = NVL(S.AVG_PROGRESS, P.PROGRESS_PCT),
          P.STATUS = CASE
                       WHEN S.TOTAL_CNT IS NULL THEN P.STATUS
                       WHEN S.DONE_CNT = S.TOTAL_CNT AND S.TOTAL_CNT > 0 THEN 'DONE'
                       WHEN S.DONE_CNT = 0 THEN 'TODO'
                       ELSE 'IN_PROGRESS'
                     END,
          P.UPDATED_AT = SYSTIMESTAMP;
    END LOOP;
  END AFTER STATEMENT;
END;
/

--------------------------------------------------------------------------------
-- (F) ACTIVITY LOGGING PACKAGE + TRIGGERS
--------------------------------------------------------------------------------
-- The app should set the actor with: DBMS_SESSION.SET_IDENTIFIER('<userId|username>');
-- Triggers call this package to write logs.

CREATE OR REPLACE PACKAGE UPNEXT_LOG AS
  PROCEDURE LOG_CHANGE (
    P_ENTITY_TYPE IN VARCHAR2,
    P_ENTITY_ID   IN NUMBER,
    P_ACTION      IN VARCHAR2,
    P_PROJECT_ID  IN NUMBER DEFAULT NULL,
    P_TASK_ID     IN NUMBER DEFAULT NULL,
    P_DETAILS     IN CLOB   DEFAULT NULL
  );
END;
/
CREATE OR REPLACE PACKAGE BODY UPNEXT_LOG AS
  PROCEDURE LOG_CHANGE (
    P_ENTITY_TYPE IN VARCHAR2,
    P_ENTITY_ID   IN NUMBER,
    P_ACTION      IN VARCHAR2,
    P_PROJECT_ID  IN NUMBER,
    P_TASK_ID     IN NUMBER,
    P_DETAILS     IN CLOB
  ) IS
    V_ACTOR VARCHAR2(128) := SYS_CONTEXT('USERENV','CLIENT_IDENTIFIER');
  BEGIN
    INSERT INTO ACTIVITY_LOGS (LOG_ID, OCCURRED_AT, ENTITY_TYPE, ENTITY_ID, ACTION, PERFORMED_BY, PROJECT_ID, TASK_ID, DETAILS)
    VALUES (ACTIVITY_LOGS_SEQ.NEXTVAL, SYSTIMESTAMP, P_ENTITY_TYPE, P_ENTITY_ID, P_ACTION, V_ACTOR, P_PROJECT_ID, P_TASK_ID, P_DETAILS);
  END;
END;
/

-- PROJECTS logging
CREATE OR REPLACE TRIGGER TRG_PROJECTS_AUD
AFTER INSERT OR UPDATE OR DELETE ON PROJECTS
FOR EACH ROW
BEGIN
  IF INSERTING THEN
    UPNEXT_LOG.LOG_CHANGE('PROJECT', :NEW.PROJECT_ID, 'INSERT', :NEW.PROJECT_ID, NULL,
      TO_CLOB('{"name":"'||REPLACE(:NEW.NAME,'"','\"')||'"}'));
  ELSIF UPDATING THEN
    UPNEXT_LOG.LOG_CHANGE('PROJECT', :NEW.PROJECT_ID, 'UPDATE', :NEW.PROJECT_ID, NULL, NULL);
  ELSIF DELETING THEN
    UPNEXT_LOG.LOG_CHANGE('PROJECT', :OLD.PROJECT_ID, 'DELETE', :OLD.PROJECT_ID, NULL, NULL);
  END IF;
END;
/

-- TASKS logging
CREATE OR REPLACE TRIGGER TRG_TASKS_AUD
AFTER INSERT OR UPDATE OR DELETE ON TASKS
FOR EACH ROW
BEGIN
  IF INSERTING THEN
    UPNEXT_LOG.LOG_CHANGE('TASK', :NEW.TASK_ID, 'INSERT', :NEW.PROJECT_ID, :NEW.TASK_ID,
      TO_CLOB('{"title":"'||REPLACE(:NEW.TITLE,'"','\"')||'","status":"'||:NEW.STATUS||'"}'));
  ELSIF UPDATING THEN
    UPNEXT_LOG.LOG_CHANGE('TASK', :NEW.TASK_ID, 'UPDATE', :NEW.PROJECT_ID, :NEW.TASK_ID, NULL);
  ELSIF DELETING THEN
    UPNEXT_LOG.LOG_CHANGE('TASK', :OLD.TASK_ID, 'DELETE', :OLD.PROJECT_ID, :OLD.TASK_ID, NULL);
  END IF;
END;
/

-- PROJECT_MEMBERS logging
CREATE OR REPLACE TRIGGER TRG_PM_AUD
AFTER INSERT OR UPDATE OR DELETE ON PROJECT_MEMBERS
FOR EACH ROW
BEGIN
  IF INSERTING THEN
    UPNEXT_LOG.LOG_CHANGE('PROJECT_MEMBER', :NEW.PROJECT_MEMBER_ID, 'INSERT', :NEW.PROJECT_ID, NULL, NULL);
  ELSIF UPDATING THEN
    UPNEXT_LOG.LOG_CHANGE('PROJECT_MEMBER', :NEW.PROJECT_MEMBER_ID, 'UPDATE', :NEW.PROJECT_ID, NULL, NULL);
  ELSIF DELETING THEN
    UPNEXT_LOG.LOG_CHANGE('PROJECT_MEMBER', :OLD.PROJECT_MEMBER_ID, 'DELETE', :OLD.PROJECT_ID, NULL, NULL);
  END IF;
END;
/

-- TASK_DEPENDENCIES logging
CREATE OR REPLACE TRIGGER TRG_DEP_AUD
AFTER INSERT OR UPDATE OR DELETE ON TASK_DEPENDENCIES
FOR EACH ROW
BEGIN
  IF INSERTING THEN
    UPNEXT_LOG.LOG_CHANGE('TASK_DEPENDENCY', :NEW.DEP_ID, 'INSERT', NULL, :NEW.SUCCESSOR_TASK_ID,
      TO_CLOB('{"predecessor":'||:NEW.PREDECESSOR_TASK_ID||',"successor":'||:NEW.SUCCESSOR_TASK_ID||'}'));
  ELSIF UPDATING THEN
    UPNEXT_LOG.LOG_CHANGE('TASK_DEPENDENCY', :NEW.DEP_ID, 'UPDATE', NULL, :NEW.SUCCESSOR_TASK_ID, NULL);
  ELSIF DELETING THEN
    UPNEXT_LOG.LOG_CHANGE('TASK_DEPENDENCY', :OLD.DEP_ID, 'DELETE', NULL, :OLD.SUCCESSOR_TASK_ID, NULL);
  END IF;
END;
/

--------------------------------------------------------------------------------
-- (G) REPORTING VIEWS
--------------------------------------------------------------------------------

-- Subtasks convenience view (all tasks that have a parent)
CREATE OR REPLACE VIEW VW_SUBTASKS AS
SELECT *
  FROM TASKS
 WHERE PARENT_TASK_ID IS NOT NULL;

-- Project progress: total tasks, completed tasks, % complete (by count)
CREATE OR REPLACE VIEW VW_PROJECT_PROGRESS AS
SELECT
  P.PROJECT_ID,
  P.NAME                    AS PROJECT_NAME,
  COUNT(T.TASK_ID)          AS TOTAL_TASKS,
  SUM(CASE WHEN T.STATUS='DONE' THEN 1 ELSE 0 END) AS COMPLETED_TASKS,
  CASE
    WHEN COUNT(T.TASK_ID)=0 THEN 0
    ELSE ROUND(100 * SUM(CASE WHEN T.STATUS='DONE' THEN 1 ELSE 0 END) / COUNT(T.TASK_ID), 2)
  END AS PERCENT_COMPLETE_BY_COUNT,
  ROUND(NVL(AVG(T.PROGRESS_PCT),0), 2) AS AVG_PROGRESS_PCT
FROM PROJECTS P
LEFT JOIN TASKS T ON T.PROJECT_ID = P.PROJECT_ID
GROUP BY P.PROJECT_ID, P.NAME;

-- Overdue tasks (not DONE/CANCELLED and due date in the past)
CREATE OR REPLACE VIEW VW_OVERDUE_TASKS AS
SELECT
  T.TASK_ID,
  T.PROJECT_ID,
  T.TITLE,
  T.STATUS,
  T.PRIORITY,
  T.ASSIGNEE_ID,
  T.DUE_DATE,
  (TRUNC(SYSDATE) - TRUNC(T.DUE_DATE)) AS DAYS_OVERDUE
FROM TASKS T
WHERE T.DUE_DATE IS NOT NULL
  AND T.STATUS NOT IN ('DONE','CANCELLED')
  AND T.DUE_DATE < SYSDATE;

-- Blocked tasks (has at least one unfinished predecessor)
CREATE OR REPLACE VIEW VW_BLOCKED_TASKS AS
SELECT S.TASK_ID, S.PROJECT_ID, S.TITLE, S.STATUS, S.PRIORITY, S.ASSIGNEE_ID
FROM TASKS S
WHERE EXISTS (
  SELECT 1
    FROM TASK_DEPENDENCIES D
    JOIN TASKS P ON P.TASK_ID = D.PREDECESSOR_TASK_ID
   WHERE D.SUCCESSOR_TASK_ID = S.TASK_ID
     AND P.STATUS <> 'DONE'
);

--------------------------------------------------------------------------------
-- (H) OPTIONAL: SIMPLE OVERDUE ALERT INSERT (for UI polling)
--------------------------------------------------------------------------------
-- Call this procedure from app or a DB job if you want persisted alerts.
CREATE OR REPLACE PROCEDURE PRC_RAISE_OVERDUE_NOTIFICATIONS AS
BEGIN
  INSERT INTO NOTIFICATIONS (NOTIF_ID, USER_ID, TASK_ID, MESSAGE, IS_READ, CREATED_AT)
  SELECT NOTIFICATIONS_SEQ.NEXTVAL,
         NVL(T.ASSIGNEE_ID, P.OWNER_ID) AS USER_ID,
         T.TASK_ID,
         'Task "'||T.TITLE||'" is overdue by '||(TRUNC(SYSDATE) - TRUNC(T.DUE_DATE))||' day(s).',
         'N',
         SYSTIMESTAMP
  FROM TASKS T
  JOIN PROJECTS P ON P.PROJECT_ID = T.PROJECT_ID
  LEFT JOIN VW_OVERDUE_TASKS V ON V.TASK_ID = T.TASK_ID
  WHERE V.TASK_ID IS NOT NULL
    AND NOT EXISTS (
      SELECT 1 FROM NOTIFICATIONS N
       WHERE N.TASK_ID = T.TASK_ID
         AND N.MESSAGE LIKE 'Task "% is overdue%'
         AND N.IS_READ = 'N'
    );
END;
/
--------------------------------------------------------------------------------
-- End of schema
--------------------------------------------------------------------------------

COMMIT;


