--------------------------------------------------------------------------------
-- UpNext Task Management System - Oracle 19c Schema
-- Run as schema owner (e.g., user UPNEXT).
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (A) TABLES
--------------------------------------------------------------------------------

-- USERS: Authentication + global role (ADMIN / MANAGER / MEMBER)
CREATE TABLE USERS (
  USER_ID           NUMBER(10)        PRIMARY KEY,
  USERNAME          VARCHAR2(50)      NOT NULL UNIQUE,
  EMAIL             VARCHAR2(120)     NOT NULL UNIQUE,
  PASSWORD_HASH     VARCHAR2(255)     NOT NULL,
  GLOBAL_ROLE       VARCHAR2(20)      NOT NULL
                     CHECK (GLOBAL_ROLE IN ('ADMIN','MANAGER','MEMBER')),
  STATUS            VARCHAR2(20)      DEFAULT 'ACTIVE'
                     CHECK (STATUS IN ('ACTIVE','SUSPENDED')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_AT        TIMESTAMP
);

-- PROJECTS
CREATE TABLE PROJECTS (
  PROJECT_ID        NUMBER(10)        PRIMARY KEY,
  NAME              VARCHAR2(120)     NOT NULL,
  DESCRIPTION       CLOB,
  OWNER_ID          NUMBER(10)        NOT NULL,
  START_DATE        DATE,
  END_DATE          DATE,
  STATUS            VARCHAR2(20)      DEFAULT 'PLANNING'
                     CHECK (STATUS IN ('PLANNING','ACTIVE','ON_HOLD','COMPLETED','CANCELLED')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_AT        TIMESTAMP,
  CONSTRAINT FK_PROJECTS_OWNER
    FOREIGN KEY (OWNER_ID) REFERENCES USERS(USER_ID)
);

-- PROJECT_MEMBERS (per-project role)
CREATE TABLE PROJECT_MEMBERS (
  PROJECT_MEMBER_ID NUMBER(10)        PRIMARY KEY,
  PROJECT_ID        NUMBER(10)        NOT NULL,
  USER_ID           NUMBER(10)        NOT NULL,
  PROJECT_ROLE      VARCHAR2(20)      NOT NULL
                     CHECK (PROJECT_ROLE IN ('OWNER','MANAGER','MEMBER','VIEWER')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_AT        TIMESTAMP,
  CONSTRAINT UQ_PROJECT_MEM UNIQUE (PROJECT_ID, USER_ID),
  CONSTRAINT FK_PM_PROJECT FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID) ON DELETE CASCADE,
  CONSTRAINT FK_PM_USER    FOREIGN KEY (USER_ID)    REFERENCES USERS(USER_ID)    ON DELETE CASCADE
);

-- TASKS (hierarchical via PARENT_TASK_ID)
CREATE TABLE TASKS (
  TASK_ID           NUMBER(10)        PRIMARY KEY,
  PROJECT_ID        NUMBER(10)        NOT NULL,
  PARENT_TASK_ID    NUMBER(10),  -- NULL for top-level tasks
  TITLE             VARCHAR2(200)     NOT NULL,
  DESCRIPTION       CLOB,
  ASSIGNEE_ID       NUMBER(10),       -- nullable
  STATUS            VARCHAR2(20)      DEFAULT 'TODO'
                     CHECK (STATUS IN ('TODO','IN_PROGRESS','BLOCKED','ON_HOLD','DONE','CANCELLED')),
  PRIORITY          VARCHAR2(10)      DEFAULT 'MEDIUM'
                     CHECK (PRIORITY IN ('LOW','MEDIUM','HIGH','CRITICAL')),
  START_DATE        DATE,
  DUE_DATE          DATE,
  PROGRESS_PCT      NUMBER(5,2)       DEFAULT 0
                     CHECK (PROGRESS_PCT BETWEEN 0 AND 100),
  ESTIMATED_HOURS   NUMBER(7,2),
  ACTUAL_HOURS      NUMBER(7,2),
  IS_BLOCKED        CHAR(1)           DEFAULT 'N'
                     CHECK (IS_BLOCKED IN ('Y','N')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  UPDATED_AT        TIMESTAMP,
  CONSTRAINT FK_TASKS_PROJECT FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID) ON DELETE CASCADE,
  CONSTRAINT FK_TASKS_PARENT  FOREIGN KEY (PARENT_TASK_ID) REFERENCES TASKS(TASK_ID) ON DELETE CASCADE,
  CONSTRAINT FK_TASKS_ASSIGNEE FOREIGN KEY (ASSIGNEE_ID) REFERENCES USERS(USER_ID),
  CONSTRAINT CHK_TASK_DATES CHECK (DUE_DATE IS NULL OR START_DATE IS NULL OR DUE_DATE >= START_DATE)
);

-- TASK_DEPENDENCIES (many-to-many: predecessor blocks successor)
CREATE TABLE TASK_DEPENDENCIES (
  DEP_ID             NUMBER(10) PRIMARY KEY,
  PREDECESSOR_TASK_ID NUMBER(10) NOT NULL,
  SUCCESSOR_TASK_ID   NUMBER(10) NOT NULL,
  CREATED_AT          TIMESTAMP   DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT UQ_TASK_DEP UNIQUE (PREDECESSOR_TASK_ID, SUCCESSOR_TASK_ID),
  CONSTRAINT CHK_NO_SELF_DEP CHECK (PREDECESSOR_TASK_ID <> SUCCESSOR_TASK_ID),
  CONSTRAINT FK_DEP_PRED FOREIGN KEY (PREDECESSOR_TASK_ID) REFERENCES TASKS(TASK_ID) ON DELETE CASCADE,
  CONSTRAINT FK_DEP_SUCC FOREIGN KEY (SUCCESSOR_TASK_ID)   REFERENCES TASKS(TASK_ID) ON DELETE CASCADE
);

-- COMMENTS (optional but useful)
CREATE TABLE COMMENTS (
  COMMENT_ID        NUMBER(10)        PRIMARY KEY,
  TASK_ID           NUMBER(10)        NOT NULL,
  USER_ID           NUMBER(10)        NOT NULL,
  CONTENT           CLOB              NOT NULL,
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT FK_COM_TASK FOREIGN KEY (TASK_ID) REFERENCES TASKS(TASK_ID) ON DELETE CASCADE,
  CONSTRAINT FK_COM_USER FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID) ON DELETE CASCADE
);

-- ATTACHMENTS (optional)
CREATE TABLE ATTACHMENTS (
  ATTACHMENT_ID     NUMBER(10)        PRIMARY KEY,
  TASK_ID           NUMBER(10)        NOT NULL,
  FILE_NAME         VARCHAR2(255)     NOT NULL,
  FILE_PATH         VARCHAR2(1024)    NOT NULL,
  UPLOADED_BY       NUMBER(10)        NOT NULL,
  UPLOADED_AT       TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT FK_ATT_TASK FOREIGN KEY (TASK_ID)     REFERENCES TASKS(TASK_ID) ON DELETE CASCADE,
  CONSTRAINT FK_ATT_USER FOREIGN KEY (UPLOADED_BY) REFERENCES USERS(USER_ID)
);

-- ACTIVITY_LOGS (captures DML on key tables)
CREATE TABLE ACTIVITY_LOGS (
  LOG_ID            NUMBER(12)        PRIMARY KEY,
  OCCURRED_AT       TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  ENTITY_TYPE       VARCHAR2(30)      NOT NULL,   -- 'PROJECT','TASK','PROJECT_MEMBER','TASK_DEPENDENCY', etc.
  ENTITY_ID         NUMBER(12)        NOT NULL,
  ACTION            VARCHAR2(10)      NOT NULL
                     CHECK (ACTION IN ('INSERT','UPDATE','DELETE')),
  PERFORMED_BY      VARCHAR2(128),                  -- set via DBMS_SESSION.SET_IDENTIFIER from app
  PROJECT_ID        NUMBER(10),
  TASK_ID           NUMBER(10),
  DETAILS           CLOB,                           -- JSON-like text
  CONSTRAINT FK_LOG_PROJ FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID),
  CONSTRAINT FK_LOG_TASK FOREIGN KEY (TASK_ID)     REFERENCES TASKS(TASK_ID)
);

-- NOTIFICATIONS (overdue/alerts; UI can poll this)
CREATE TABLE NOTIFICATIONS (
  NOTIF_ID          NUMBER(12)        PRIMARY KEY,
  USER_ID           NUMBER(10)        NOT NULL,
  TASK_ID           NUMBER(10),
  MESSAGE           VARCHAR2(4000)    NOT NULL,
  IS_READ           CHAR(1)           DEFAULT 'N' CHECK (IS_READ IN ('Y','N')),
  CREATED_AT        TIMESTAMP         DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT FK_NOTIF_USER FOREIGN KEY (USER_ID) REFERENCES USERS(USER_ID),
  CONSTRAINT FK_NOTIF_TASK FOREIGN KEY (TASK_ID) REFERENCES TASKS(TASK_ID) ON DELETE CASCADE
);

--------------------------------------------------------------------------------
-- (B) INDEXES
--------------------------------------------------------------------------------
CREATE INDEX IX_PROJECTS_OWNER      ON PROJECTS(OWNER_ID);
CREATE INDEX IX_PM_PROJECT          ON PROJECT_MEMBERS(PROJECT_ID);
CREATE INDEX IX_PM_USER             ON PROJECT_MEMBERS(USER_ID);

CREATE INDEX IX_TASKS_PROJECT       ON TASKS(PROJECT_ID);
CREATE INDEX IX_TASKS_PARENT        ON TASKS(PARENT_TASK_ID);
CREATE INDEX IX_TASKS_ASSIGNEE      ON TASKS(ASSIGNEE_ID);
CREATE INDEX IX_TASKS_STATUS        ON TASKS(STATUS);
CREATE INDEX IX_TASKS_DUE_DATE      ON TASKS(DUE_DATE);

CREATE INDEX IX_DEP_PRED            ON TASK_DEPENDENCIES(PREDECESSOR_TASK_ID);
CREATE INDEX IX_DEP_SUCC            ON TASK_DEPENDENCIES(SUCCESSOR_TASK_ID);

CREATE INDEX IX_LOGS_ENTITY         ON ACTIVITY_LOGS(ENTITY_TYPE, ENTITY_ID);
CREATE INDEX IX_LOGS_PROJECT        ON ACTIVITY_LOGS(PROJECT_ID);
CREATE INDEX IX_LOGS_TASK           ON ACTIVITY_LOGS(TASK_ID);

CREATE INDEX IX_NOTIF_USER          ON NOTIFICATIONS(USER_ID);
CREATE INDEX IX_NOTIF_TASK          ON NOTIFICATIONS(TASK_ID);

--------------------------------------------------------------------------------
-- (C) SEQUENCES
--------------------------------------------------------------------------------
CREATE SEQUENCE USERS_SEQ              START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE PROJECTS_SEQ           START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE PROJECT_MEMBERS_SEQ    START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE TASKS_SEQ              START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE TASK_DEP_SEQ           START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE COMMENTS_SEQ           START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE ATTACHMENTS_SEQ        START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE ACTIVITY_LOGS_SEQ      START WITH 1 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE NOTIFICATIONS_SEQ      START WITH 1 INCREMENT BY 1 NOCACHE;

--------------------------------------------------------------------------------
-- (D) ID / TIMESTAMP TRIGGERS
--------------------------------------------------------------------------------
-- USERS
CREATE OR REPLACE TRIGGER TRG_USERS_BI
BEFORE INSERT ON USERS
FOR EACH ROW
BEGIN
  IF :NEW.USER_ID IS NULL THEN
    SELECT USERS_SEQ.NEXTVAL INTO :NEW.USER_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TRG_USERS_BU
BEFORE UPDATE ON USERS
FOR EACH ROW
BEGIN
  :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/

-- PROJECTS
CREATE OR REPLACE TRIGGER TRG_PROJECTS_BI
BEFORE INSERT ON PROJECTS
FOR EACH ROW
BEGIN
  IF :NEW.PROJECT_ID IS NULL THEN
    SELECT PROJECTS_SEQ.NEXTVAL INTO :NEW.PROJECT_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TRG_PROJECTS_BU
BEFORE UPDATE ON PROJECTS
FOR EACH ROW
BEGIN
  :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/

-- PROJECT_MEMBERS
CREATE OR REPLACE TRIGGER TRG_PM_BI
BEFORE INSERT ON PROJECT_MEMBERS
FOR EACH ROW
BEGIN
  IF :NEW.PROJECT_MEMBER_ID IS NULL THEN
    SELECT PROJECT_MEMBERS_SEQ.NEXTVAL INTO :NEW.PROJECT_MEMBER_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TRG_PM_BU
BEFORE UPDATE ON PROJECT_MEMBERS
FOR EACH ROW
BEGIN
  :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/

-- TASKS
CREATE OR REPLACE TRIGGER TRG_TASKS_BI
BEFORE INSERT ON TASKS
FOR EACH ROW
BEGIN
  IF :NEW.TASK_ID IS NULL THEN
    SELECT TASKS_SEQ.NEXTVAL INTO :NEW.TASK_ID FROM DUAL;
  END IF;
  :NEW.PROGRESS_PCT := NVL(:NEW.PROGRESS_PCT, 0);
  :NEW.IS_BLOCKED   := NVL(:NEW.IS_BLOCKED, 'N');
  :NEW.CREATED_AT   := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/
CREATE OR REPLACE TRIGGER TRG_TASKS_BU
BEFORE UPDATE ON TASKS
FOR EACH ROW
BEGIN
  :NEW.UPDATED_AT := SYSTIMESTAMP;
END;
/

-- TASK_DEPENDENCIES
CREATE OR REPLACE TRIGGER TRG_DEP_BI
BEFORE INSERT ON TASK_DEPENDENCIES
FOR EACH ROW
BEGIN
  IF :NEW.DEP_ID IS NULL THEN
    SELECT TASK_DEP_SEQ.NEXTVAL INTO :NEW.DEP_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/

-- COMMENTS
CREATE OR REPLACE TRIGGER TRG_COMMENTS_BI
BEFORE INSERT ON COMMENTS
FOR EACH ROW
BEGIN
  IF :NEW.COMMENT_ID IS NULL THEN
    SELECT COMMENTS_SEQ.NEXTVAL INTO :NEW.COMMENT_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/

-- ATTACHMENTS
CREATE OR REPLACE TRIGGER TRG_ATTACHMENTS_BI
BEFORE INSERT ON ATTACHMENTS
FOR EACH ROW
BEGIN
  IF :NEW.ATTACHMENT_ID IS NULL THEN
    SELECT ATTACHMENTS_SEQ.NEXTVAL INTO :NEW.ATTACHMENT_ID FROM DUAL;
  END IF;
  :NEW.UPLOADED_AT := NVL(:NEW.UPLOADED_AT, SYSTIMESTAMP);
END;
/

-- ACTIVITY_LOGS
CREATE OR REPLACE TRIGGER TRG_LOGS_BI
BEFORE INSERT ON ACTIVITY_LOGS
FOR EACH ROW
BEGIN
  IF :NEW.LOG_ID IS NULL THEN
    SELECT ACTIVITY_LOGS_SEQ.NEXTVAL INTO :NEW.LOG_ID FROM DUAL;
  END IF;
  :NEW.OCCURRED_AT := NVL(:NEW.OCCURRED_AT, SYSTIMESTAMP);
END;
/

-- NOTIFICATIONS
CREATE OR REPLACE TRIGGER TRG_NOTIF_BI
BEFORE INSERT ON NOTIFICATIONS
FOR EACH ROW
BEGIN
  IF :NEW.NOTIF_ID IS NULL THEN
    SELECT NOTIFICATIONS_SEQ.NEXTVAL INTO :NEW.NOTIF_ID FROM DUAL;
  END IF;
  :NEW.CREATED_AT := NVL(:NEW.CREATED_AT, SYSTIMESTAMP);
END;
/

--------------------------------------------------------------------------------
-- (E) BUSINESS RULE TRIGGERS
--------------------------------------------------------------------------------

-- 1) Dependency enforcement: cannot move to IN_PROGRESS or DONE if any predecessor not DONE
CREATE OR REPLACE TRIGGER TRG_TASKS_CHECK_DEPS
BEFORE UPDATE OF STATUS ON TASKS
FOR EACH ROW
DECLARE
  V_UNFINISHED NUMBER;
BEGIN
  IF :NEW.STATUS IN ('IN_PROGRESS','DONE') THEN
    SELECT COUNT(*)
      INTO V_UNFINISHED
      FROM TASK_DEPENDENCIES D
      JOIN TASKS P ON P.TASK_ID = D.PREDECESSOR_TASK_ID
     WHERE D.SUCCESSOR_TASK_ID = :NEW.TASK_ID
       AND P.STATUS <> 'DONE';
    IF V_UNFINISHED > 0 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Task has unfinished dependencies and cannot be '||:NEW.STATUS);
    END IF;
  END IF;
END;
/


DROP TRIGGER UPNEXT.TRG_TASKS_CHECK_DEPS;

-- (Optional) prevent setting PROGRESS_PCT to 100 unless status DONE
CREATE OR REPLACE TRIGGER TRG_TASKS_PROGRESS_GUARD
BEFORE UPDATE OF PROGRESS_PCT ON TASKS
FOR EACH ROW
BEGIN
  EXECUTE IMMEDIATE 'DROP TRIGGER TRG_TASKS_STATUS_RECALC_BLOCK';
EXCEPTION
  WHEN OTHERS THEN
    IF SQLCODE <> -4080 THEN RAISE; END IF;  -- -4080 = trigger does not exist
END;
/

-- Recreate as a statemen-level trigger (NO "FOR EACH ROW")
CREATE OR REPLACE TRIGGER TRG_TASKS_STATUS_RECALC_BLOCK
AFTER UPDATE OF STATUS ON TASKS
BEGIN
  UPDATE TASKS S
     SET IS_BLOCKED =
       CASE
         WHEN EXISTS (
           SELECT 1
             FROM TASK_DEPENDENCIES D
             JOIN TASKS P ON P.TASK_ID = D.PREDECESSOR_TASK_ID
            WHERE D.SUCCESSOR_TASK_ID = S.TASK_ID
              AND P.STATUS <> 'DONE'
         )
         THEN 'Y' ELSE 'N'
       END
   WHERE EXISTS (SELECT 1 FROM TASK_DEPENDENCIES D WHERE D.SUCCESSOR_TASK_ID = S.TASK_ID);
END;
/



ALTER TABLE ACTIVITY_LOGS DROP CONSTRAINT FK_LOG_PROJ;
ALTER TABLE ACTIVITY_LOGS
  ADD CONSTRAINT FK_LOG_PROJ
  FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID)
  ON DELETE CASCADE;

ALTER TABLE ACTIVITY_LOGS DROP CONSTRAINT FK_LOG_TASK;
ALTER TABLE ACTIVITY_LOGS
  ADD CONSTRAINT FK_LOG_TASK
  FOREIGN KEY (TASK_ID) REFERENCES TASKS(TASK_ID)
  ON DELETE CASCADE;


--------------------------------------------------------------------------------
-- (H) OPTIONAL: SIMPLE OVERDUE ALERT INSERT (for UI polling)
--------------------------------------------------------------------------------
-- Call this procedure from app or a DB job if you want persisted alerts.
CREATE OR REPLACE PROCEDURE PRC_RAISE_OVERDUE_NOTIFICATIONS AS
BEGIN
  INSERT INTO NOTIFICATIONS (NOTIF_ID, USER_ID, TASK_ID, MESSAGE, IS_READ, CREATED_AT)
  SELECT NOTIFICATIONS_SEQ.NEXTVAL,
         NVL(T.ASSIGNEE_ID, P.OWNER_ID) AS USER_ID,
         T.TASK_ID,
         'Task "'||T.TITLE||'" is overdue by '||(TRUNC(SYSDATE) - TRUNC(T.DUE_DATE))||' day(s).',
         'N',
         SYSTIMESTAMP
  FROM TASKS T
  JOIN PROJECTS P ON P.PROJECT_ID = T.PROJECT_ID
  LEFT JOIN VW_OVERDUE_TASKS V ON V.TASK_ID = T.TASK_ID
  WHERE V.TASK_ID IS NOT NULL
    AND NOT EXISTS (
      SELECT 1 FROM NOTIFICATIONS N
       WHERE N.TASK_ID = T.TASK_ID
         AND N.MESSAGE LIKE 'Task "% is overdue%'
         AND N.IS_READ = 'N'
    );
END;
/


commit;
--------------------------------------------------------------------------------
-- End of schema
--------------------------------------------------------------------------------

-- SHA256('admin123') = 240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9
INSERT INTO USERS (USER_ID, USERNAME, EMAIL, PASSWORD_HASH, GLOBAL_ROLE, STATUS)
VALUES (USERS_SEQ.NEXTVAL, 'admin', 'admin@example.com',
        '240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9',
        'ADMIN', 'ACTIVE');


ALTER TABLE projects ADD (assigned_manager_id NUMBER);

ALTER TABLE projects
  ADD CONSTRAINT fk_proj_manager FOREIGN KEY (assigned_manager_id)
  REFERENCES users(user_id);
  
  
CREATE OR REPLACE TRIGGER TRG_TASKS_ROLLUP
FOR INSERT OR UPDATE OF STATUS ON TASKS
COMPOUND TRIGGER

  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  g_parent_ids num_tab;
  g_count      PLS_INTEGER := 0;

  PROCEDURE add_parent(p_id NUMBER) IS
    i PLS_INTEGER; found BOOLEAN := FALSE;
  BEGIN
    IF p_id IS NOT NULL THEN
      i := g_parent_ids.FIRST;
      WHILE i IS NOT NULL LOOP
        IF g_parent_ids(i) = p_id THEN found := TRUE; EXIT; END IF;
        i := g_parent_ids.NEXT(i);
      END LOOP;
      IF NOT found THEN
        g_count := NVL(g_count,0) + 1;
        g_parent_ids(g_count) := p_id;
      END IF;
    END IF;
  END;

  BEFORE STATEMENT IS
  BEGIN
    g_parent_ids.DELETE; g_count := 0;
  END BEFORE STATEMENT;

  AFTER EACH ROW IS
  BEGIN
    IF INSERTING OR UPDATING('STATUS') THEN
      add_parent(:NEW.PARENT_TASK_ID);
    END IF;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
    IF g_parent_ids.COUNT > 0 THEN
      FOR i IN g_parent_ids.FIRST .. g_parent_ids.LAST LOOP
        IF g_parent_ids.EXISTS(i) THEN
          DECLARE
            v_pid      NUMBER := g_parent_ids(i);
            v_total    NUMBER;
            v_not_done NUMBER;
          BEGIN
            IF v_pid IS NOT NULL THEN
              -- If new child exists under a DONE parent, flip to IN_PROGRESS
              UPDATE TASKS
                 SET STATUS='IN_PROGRESS', UPDATED_AT=SYSTIMESTAMP
               WHERE TASK_ID = v_pid AND STATUS='DONE';

              -- If all children are DONE, set parent DONE
              SELECT COUNT(*),
                     SUM(CASE WHEN UPPER(STATUS) <> 'DONE' THEN 1 ELSE 0 END)
                INTO v_total, v_not_done
                FROM TASKS
               WHERE PARENT_TASK_ID = v_pid;

              IF v_total > 0 AND v_not_done = 0 THEN
                UPDATE TASKS
                   SET STATUS='DONE', UPDATED_AT=SYSTIMESTAMP
                 WHERE TASK_ID = v_pid AND STATUS <> 'DONE';
              END IF;
            END IF;
          END;
        END IF;
      END LOOP;
    END IF;
  END AFTER STATEMENT;

END TRG_TASKS_ROLLUP;
/


SELECT trigger_name, triggering_event, trigger_type, status
FROM USER_TRIGGERS
WHERE TABLE_NAME = 'TASKS';

DROP TRIGGER UPNEXT.TRG_ROLLUP_PARENT_DONE;
commit;

--------------------------------------------------------------------------------
-- End of schema
--------------------------------------------------------------------------------

